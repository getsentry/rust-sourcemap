{"sections":[{"map":{"sections":[{"map":{"version":3,"sources":["__prelude__"],"sourcesContent":["var __BUNDLE_START_TIME__=this.nativePerformanceNow?nativePerformanceNow():Date.now(),__DEV__=false,process=this.process||{};process.env=process.env||{};process.env.NODE_ENV=process.env.NODE_ENV||\"production\";"],"names":[],"mappings":""},"offset":{"line":0,"column":0}},{"map":{"version":3,"sources":["/Users/anton/reps/tmp/ram-bundles-test/metro-test/node_modules/metro/src/lib/polyfills/require.js"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @polyfill\n *\n * @format\n */\n\"use strict\";\n/* eslint-disable no-bitwise */\n\nglobal.__r = metroRequire;\nglobal.__d = define;\nglobal.__c = clear;\nglobal.__registerSegment = registerSegment;\nvar modules = clear(); // Don't use a Symbol here, it would pull in an extra polyfill with all sorts of\n// additional stuff (e.g. Array.from).\n\nconst EMPTY = {};\nconst _ref = {},\n  hasOwnProperty = _ref.hasOwnProperty;\n\nfunction clear() {\n  modules = Object.create(null); // We return modules here so that we can assign an initial value to modules\n  // when defining it. Otherwise, we would have to do \"let modules = null\",\n  // which will force us to add \"nullthrows\" everywhere.\n\n  return modules;\n}\n\nif (__DEV__) {\n  var verboseNamesToModuleIds = Object.create(null);\n  var initializingModuleIds = [];\n}\n\nfunction define(factory, moduleId, dependencyMap) {\n  if (modules[moduleId] != null) {\n    if (__DEV__) {\n      // (We take `inverseDependencies` from `arguments` to avoid an unused\n      // named parameter in `define` in production.\n      const inverseDependencies = arguments[4]; // If the module has already been defined and the define method has been\n      // called with inverseDependencies, we can hot reload it.\n\n      if (inverseDependencies) {\n        global.__accept(moduleId, factory, dependencyMap, inverseDependencies);\n      }\n    } // prevent repeated calls to `global.nativeRequire` to overwrite modules\n    // that are already loaded\n\n    return;\n  }\n\n  modules[moduleId] = {\n    dependencyMap,\n    factory,\n    hasError: false,\n    importedAll: EMPTY,\n    importedDefault: EMPTY,\n    isInitialized: false,\n    publicModule: {\n      exports: {}\n    }\n  };\n\n  if (__DEV__) {\n    // HMR\n    modules[moduleId].hot = createHotReloadingObject(); // DEBUGGABLE MODULES NAMES\n    // we take `verboseName` from `arguments` to avoid an unused named parameter\n    // in `define` in production.\n\n    const verboseName = arguments[3];\n\n    if (verboseName) {\n      modules[moduleId].verboseName = verboseName;\n      verboseNamesToModuleIds[verboseName] = moduleId;\n    }\n  }\n}\n\nfunction metroRequire(moduleId) {\n  if (__DEV__ && typeof moduleId === \"string\") {\n    const verboseName = moduleId;\n    moduleId = verboseNamesToModuleIds[verboseName];\n\n    if (moduleId == null) {\n      throw new Error(`Unknown named module: \"${verboseName}\"`);\n    } else {\n      console.warn(\n        `Requiring module \"${verboseName}\" by name is only supported for ` +\n          \"debugging purposes and will BREAK IN PRODUCTION!\"\n      );\n    }\n  } //$FlowFixMe: at this point we know that moduleId is a number\n\n  const moduleIdReallyIsNumber = moduleId;\n\n  if (__DEV__) {\n    const initializingIndex = initializingModuleIds.indexOf(\n      moduleIdReallyIsNumber\n    );\n\n    if (initializingIndex !== -1) {\n      const cycle = initializingModuleIds\n        .slice(initializingIndex)\n        .map(id => modules[id].verboseName); // We want to show A -> B -> A:\n\n      cycle.push(cycle[0]);\n      console.warn(\n        `Require cycle: ${cycle.join(\" -> \")}\\n\\n` +\n          \"Require cycles are allowed, but can result in uninitialized values. \" +\n          \"Consider refactoring to remove the need for a cycle.\"\n      );\n    }\n  }\n\n  const module = modules[moduleIdReallyIsNumber];\n  return module && module.isInitialized\n    ? module.publicModule.exports\n    : guardedLoadModule(moduleIdReallyIsNumber, module);\n}\n\nfunction metroImportDefault(moduleId) {\n  if (__DEV__ && typeof moduleId === \"string\") {\n    const verboseName = moduleId;\n    moduleId = verboseNamesToModuleIds[verboseName];\n  } //$FlowFixMe: at this point we know that moduleId is a number\n\n  const moduleIdReallyIsNumber = moduleId;\n\n  if (\n    modules[moduleIdReallyIsNumber] &&\n    modules[moduleIdReallyIsNumber].importedDefault !== EMPTY\n  ) {\n    return modules[moduleIdReallyIsNumber].importedDefault;\n  }\n\n  const exports = metroRequire(moduleIdReallyIsNumber);\n  const importedDefault =\n    exports && exports.__esModule ? exports.default : exports;\n  return (modules[moduleIdReallyIsNumber].importedDefault = importedDefault);\n}\n\nmetroRequire.importDefault = metroImportDefault;\n\nfunction metroImportAll(moduleId) {\n  if (__DEV__ && typeof moduleId === \"string\") {\n    const verboseName = moduleId;\n    moduleId = verboseNamesToModuleIds[verboseName];\n  } //$FlowFixMe: at this point we know that moduleId is a number\n\n  const moduleIdReallyIsNumber = moduleId;\n\n  if (\n    modules[moduleIdReallyIsNumber] &&\n    modules[moduleIdReallyIsNumber].importedAll !== EMPTY\n  ) {\n    return modules[moduleIdReallyIsNumber].importedAll;\n  }\n\n  const exports = metroRequire(moduleIdReallyIsNumber);\n  let importedAll;\n\n  if (exports && exports.__esModule) {\n    importedAll = exports;\n  } else {\n    importedAll = {}; // Refrain from using Object.assign, it has to work in ES3 environments.\n\n    if (exports) {\n      for (const key in exports) {\n        if (hasOwnProperty.call(exports, key)) {\n          importedAll[key] = exports[key];\n        }\n      }\n    }\n\n    importedAll.default = exports;\n  }\n\n  return (modules[moduleIdReallyIsNumber].importedAll = importedAll);\n}\n\nmetroRequire.importAll = metroImportAll;\nlet inGuard = false;\n\nfunction guardedLoadModule(moduleId, module) {\n  if (!inGuard && global.ErrorUtils) {\n    inGuard = true;\n    let returnValue;\n\n    try {\n      returnValue = loadModuleImplementation(moduleId, module);\n    } catch (e) {\n      global.ErrorUtils.reportFatalError(e);\n    }\n\n    inGuard = false;\n    return returnValue;\n  } else {\n    return loadModuleImplementation(moduleId, module);\n  }\n}\n\nconst ID_MASK_SHIFT = 16;\nconst LOCAL_ID_MASK = ~0 >>> ID_MASK_SHIFT;\n\nfunction unpackModuleId(moduleId) {\n  const segmentId = moduleId >>> ID_MASK_SHIFT;\n  const localId = moduleId & LOCAL_ID_MASK;\n  return {\n    segmentId,\n    localId\n  };\n}\n\nmetroRequire.unpackModuleId = unpackModuleId;\n\nfunction packModuleId(value) {\n  return (value.segmentId << ID_MASK_SHIFT) + value.localId;\n}\n\nmetroRequire.packModuleId = packModuleId;\nconst hooks = [];\n\nfunction registerHook(cb) {\n  const hook = {\n    cb\n  };\n  hooks.push(hook);\n  return {\n    release: () => {\n      for (let i = 0; i < hooks.length; ++i) {\n        if (hooks[i] === hook) {\n          hooks.splice(i, 1);\n          break;\n        }\n      }\n    }\n  };\n}\n\nmetroRequire.registerHook = registerHook;\nconst moduleDefinersBySegmentID = [];\n\nfunction registerSegment(segmentID, moduleDefiner) {\n  moduleDefinersBySegmentID[segmentID] = moduleDefiner;\n}\n\nfunction loadModuleImplementation(moduleId, module) {\n  if (!module && moduleDefinersBySegmentID.length > 0) {\n    const _unpackModuleId = unpackModuleId(moduleId),\n      segmentId = _unpackModuleId.segmentId,\n      localId = _unpackModuleId.localId;\n\n    const definer = moduleDefinersBySegmentID[segmentId];\n\n    if (definer != null) {\n      definer(localId);\n      module = modules[moduleId];\n    }\n  }\n\n  const nativeRequire = global.nativeRequire;\n\n  if (!module && nativeRequire) {\n    const _unpackModuleId2 = unpackModuleId(moduleId),\n      segmentId = _unpackModuleId2.segmentId,\n      localId = _unpackModuleId2.localId;\n\n    nativeRequire(localId, segmentId);\n    module = modules[moduleId];\n  }\n\n  if (!module) {\n    throw unknownModuleError(moduleId);\n  }\n\n  if (module.hasError) {\n    throw moduleThrewError(moduleId, module.error);\n  } // `metroRequire` calls into the require polyfill itself are not analyzed and\n  // replaced so that they use numeric module IDs.\n  // The systrace module will expose itself on the metroRequire function so that\n  // it can be used here.\n  // TODO(davidaurelio) Scan polyfills for dependencies, too (t9759686)\n\n  if (__DEV__) {\n    var Systrace = metroRequire.Systrace;\n  } // We must optimistically mark module as initialized before running the\n  // factory to keep any require cycles inside the factory from causing an\n  // infinite require loop.\n\n  module.isInitialized = true;\n  const _module = module,\n    factory = _module.factory,\n    dependencyMap = _module.dependencyMap;\n\n  if (__DEV__) {\n    initializingModuleIds.push(moduleId);\n  }\n\n  try {\n    if (__DEV__) {\n      // $FlowFixMe: we know that __DEV__ is const and `Systrace` exists\n      Systrace.beginEvent(\"JS_require_\" + (module.verboseName || moduleId));\n    }\n\n    const moduleObject = module.publicModule;\n\n    if (__DEV__) {\n      if (module.hot) {\n        moduleObject.hot = module.hot;\n      }\n    }\n\n    moduleObject.id = moduleId;\n\n    if (hooks.length > 0) {\n      for (let i = 0; i < hooks.length; ++i) {\n        hooks[i].cb(moduleId, moduleObject);\n      }\n    } // keep args in sync with with defineModuleCode in\n    // metro/src/Resolver/index.js\n    // and metro/src/ModuleGraph/worker.js\n\n    factory(\n      global,\n      metroRequire,\n      metroImportDefault,\n      metroImportAll,\n      moduleObject,\n      moduleObject.exports,\n      dependencyMap\n    ); // avoid removing factory in DEV mode as it breaks HMR\n\n    if (!__DEV__) {\n      // $FlowFixMe: This is only sound because we never access `factory` again\n      module.factory = undefined;\n      module.dependencyMap = undefined;\n    }\n\n    if (__DEV__) {\n      // $FlowFixMe: we know that __DEV__ is const and `Systrace` exists\n      Systrace.endEvent();\n    }\n\n    return moduleObject.exports;\n  } catch (e) {\n    module.hasError = true;\n    module.error = e;\n    module.isInitialized = false;\n    module.publicModule.exports = undefined;\n    throw e;\n  } finally {\n    if (__DEV__) {\n      if (initializingModuleIds.pop() !== moduleId) {\n        throw new Error(\n          \"initializingModuleIds is corrupt; something is terribly wrong\"\n        );\n      }\n    }\n  }\n}\n\nfunction unknownModuleError(id) {\n  let message = 'Requiring unknown module \"' + id + '\".';\n\n  if (__DEV__) {\n    message +=\n      \"If you are sure the module is there, try restarting Metro Bundler. \" +\n      \"You may also want to run `yarn`, or `npm install` (depending on your environment).\";\n  }\n\n  return Error(message);\n}\n\nfunction moduleThrewError(id, error) {\n  const displayName = (__DEV__ && modules[id] && modules[id].verboseName) || id;\n  return Error(\n    'Requiring module \"' + displayName + '\", which threw an exception: ' + error\n  );\n}\n\nif (__DEV__) {\n  metroRequire.Systrace = {\n    beginEvent: () => {},\n    endEvent: () => {}\n  };\n\n  metroRequire.getModules = () => {\n    return modules;\n  }; // HOT MODULE RELOADING\n\n  var createHotReloadingObject = function() {\n    const hot = {\n      acceptCallback: null,\n      accept: callback => {\n        hot.acceptCallback = callback;\n      },\n      disposeCallback: null,\n      dispose: callback => {\n        hot.disposeCallback = callback;\n      }\n    };\n    return hot;\n  };\n\n  const metroAcceptAll = function(\n    dependentModules,\n    inverseDependencies,\n    patchedModules\n  ) {\n    if (!dependentModules || dependentModules.length === 0) {\n      return true;\n    }\n\n    const notAccepted = dependentModules.filter(\n      module =>\n        !metroAccept(\n          module,\n          /*factory*/\n          undefined,\n          /*dependencyMap*/\n          undefined,\n          inverseDependencies,\n          patchedModules\n        )\n    );\n    const parents = [];\n\n    for (let i = 0; i < notAccepted.length; i++) {\n      // if the module has no parents then the change cannot be hot loaded\n      if (inverseDependencies[notAccepted[i]].length === 0) {\n        return false;\n      }\n\n      parents.push.apply(parents, inverseDependencies[notAccepted[i]]);\n    }\n\n    return parents.length == 0;\n  };\n\n  const metroAccept = function(\n    id,\n    factory,\n    dependencyMap,\n    inverseDependencies\n  ) {\n    let patchedModules =\n      arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n    if (id in patchedModules) {\n      // Do not patch the same module more that once during an update.\n      return true;\n    }\n\n    patchedModules[id] = true;\n    const mod = modules[id];\n\n    if (!mod && factory) {\n      // New modules are going to be handled by the define() method.\n      return true;\n    }\n\n    const hot = mod.hot;\n\n    if (!hot) {\n      console.warn(\n        \"Cannot accept module because Hot Module Replacement \" +\n          \"API was not installed.\"\n      );\n      return false;\n    }\n\n    if (hot.disposeCallback) {\n      try {\n        hot.disposeCallback();\n      } catch (error) {\n        console.error(\n          `Error while calling dispose handler for module ${id}: `,\n          error\n        );\n      }\n    } // replace and initialize factory\n\n    if (factory) {\n      mod.factory = factory;\n    }\n\n    if (dependencyMap) {\n      mod.dependencyMap = dependencyMap;\n    }\n\n    mod.hasError = false;\n    mod.isInitialized = false;\n    metroRequire(id);\n\n    if (hot.acceptCallback) {\n      try {\n        hot.acceptCallback();\n        return true;\n      } catch (error) {\n        console.error(\n          `Error while calling accept handler for module ${id}: `,\n          error\n        );\n      }\n    } // need to have inverseDependencies to bubble up accept\n\n    if (!inverseDependencies) {\n      throw new Error(\"Undefined `inverseDependencies`\");\n    } // accept parent modules recursively up until all siblings are accepted\n\n    return metroAcceptAll(\n      inverseDependencies[id],\n      inverseDependencies,\n      patchedModules\n    );\n  };\n\n  global.__accept = metroAccept;\n}\n"],"names":["global","__r","metroRequire","__d","factory","moduleId","dependencyMap","modules","hasError","importedAll","EMPTY","importedDefault","isInitialized","publicModule","exports","__c","clear","__registerSegment","segmentID","moduleDefiner","moduleDefinersBySegmentID","hasOwnProperty","Object","create","moduleIdReallyIsNumber","module","guardedLoadModule","metroImportDefault","__esModule","default","metroImportAll","key","call","importDefault","importAll","inGuard","ErrorUtils","returnValue","loadModuleImplementation","e","reportFatalError","ID_MASK_SHIFT","LOCAL_ID_MASK","unpackModuleId","segmentId","localId","packModuleId","value","hooks","registerHook","cb","hook","push","release","i","length","splice","_unpackModuleId","definer","nativeRequire","_unpackModuleId2","unknownModuleError","moduleThrewError","error","_module","moduleObject","id","undefined","Error"],"mappings":"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"},"offset":{"line":1,"column":0}},{"map":{"version":3,"sources":["require-/Users/anton/reps/tmp/ram-bundles-test/metro-test/src/index.js"],"sourcesContent":[""],"names":[],"mappings":""},"offset":{"line":2,"column":0}},{"map":{"version":3,"sources":["source-map"],"sourcesContent":[""],"names":[],"mappings":""},"offset":{"line":3,"column":0}}],"version":3},"offset":{"line":0,"column":123}},{"map":{"version":3,"sources":["/Users/anton/reps/tmp/ram-bundles-test/metro-test/src/index.js"],"sourcesContent":["const f = require(\"./other\");\nconst isWindows = require(\"is-windows\"); // 3rd party package\n\nconsole.log(\"inside index.js\");\nconsole.log(f(\"world\"));\nconsole.log(\"Is Windows OS: \" + isWindows());\n"],"names":["f","require","d","isWindows","console","log"],"mappings":"yCAAA,MAAMA,EAAIC,EAAOC,EAAA,IACXC,EAAYF,EAAOC,EAAA,IAEzBE,QAAQC,IAAI,mBACZD,QAAQC,IAAIL,EAAE,UACdI,QAAQC,IAAI,kBAAoBF"},"offset":{"line":4,"column":28}},{"map":{"version":3,"sources":["/Users/anton/reps/tmp/ram-bundles-test/metro-test/src/other.js"],"sourcesContent":["console.log('inside other.js');\nmodule.exports = s => \"hello, \" + s;\n"],"names":["console","log","module","exports","s"],"mappings":"yCAAAA,QAAQC,IAAI,mBACZC,EAAOC,QAAUC,CAAAA,GAAK,UAAYA"},"offset":{"line":5,"column":28}},{"map":{"version":3,"sources":["/Users/anton/reps/tmp/ram-bundles-test/metro-test/node_modules/is-windows/index.js"],"sourcesContent":["/*!\n * is-windows <https://github.com/jonschlinkert/is-windows>\n *\n * Copyright © 2015-2018, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n(function(factory) {\n  if (exports && typeof exports === 'object' && typeof module !== 'undefined') {\n    module.exports = factory();\n  } else if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  } else if (typeof window !== 'undefined') {\n    window.isWindows = factory();\n  } else if (typeof global !== 'undefined') {\n    global.isWindows = factory();\n  } else if (typeof self !== 'undefined') {\n    self.isWindows = factory();\n  } else {\n    this.isWindows = factory();\n  }\n})(function() {\n  'use strict';\n  return function isWindows() {\n    return process && (process.platform === 'win32' || /^(msys|cygwin)$/.test(process.env.OSTYPE));\n  };\n});\n"],"names":["factory","exports","module","define","amd","window","isWindows","global","self","this","process","platform","test","env","OSTYPE"],"mappings":"2CAOA,SAAUA,GACJC,GAA8B,iBAAZA,QAA0C,IAAXC,EACnDA,EAAOD,QAAUD,IACU,mBAAXG,QAAyBA,OAAOC,IAChDD,UAAWH,GACgB,oBAAXK,OAChBA,OAAOC,UAAYN,SACQ,IAAXO,EAChBA,EAAOD,UAAYN,IACM,oBAATQ,KAChBA,KAAKF,UAAYN,IAEjBS,KAAKH,UAAYN,KAZrB,CAcG,WAED,OAAO,WACL,OAAOU,UAAiC,UAArBA,QAAQC,UAAwB,kBAAkBC,KAAKF,QAAQG,IAAIC"},"offset":{"line":6,"column":28}}],"version":3,"x_facebook_offsets":[4,null,null,5,6],"x_metro_module_paths":["/Users/anton/reps/tmp/ram-bundles-test/metro-test/src/index.js","__prelude__","/Users/anton/reps/tmp/ram-bundles-test/metro-test/node_modules/metro/src/lib/polyfills/require.js","/Users/anton/reps/tmp/ram-bundles-test/metro-test/src/other.js","/Users/anton/reps/tmp/ram-bundles-test/metro-test/node_modules/is-windows/index.js","require-/Users/anton/reps/tmp/ram-bundles-test/metro-test/src/index.js","source-map"]}